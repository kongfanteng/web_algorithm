/**
 * @example
 *
 * ```js
    // 重复子问题优化
    // - 对于斐波那契数列
    // - 1, 1, 2, 3, 5, 8, 13, 21...
    function fib (n) {
      return n <= 1 ? 1 : fib(n-1) + fib(n-2)
    }

    // - 执行树
    // - - fib(5) 中 fib(3) 求解了 2 次，fib(2) 求解了 3 次，fib(1) 求解了 5 次

    // - 递归树
    // - - 树的高度为 n
    // - - 第 1 层-第 n-2 层节点是满的
    // - - 总节数量 > (2 的 n-1 次方)

    // - 优化策略（动态规划）
    // - - a 代表 fib(n-2)
    // - - b 代表 fib(n-1)
    // - - 通过循环构造 f(n)，复杂度由 O(2^n) -> O(n)

    // - 调用
    console.log(fib(20)) // 10946
 * ```
 * 
 */
function fib(n) {
  let a = 1,
    b = 1
  for (let i = 2; i <= n; i++) {
    [b, a] = [a + b, b]
  }
  return b
}

/**
 * 蚂蚁爬楼梯问题
 * @example
 *
 * ```js
    // 爬楼梯问题
    // - 一只蚂蚁爬 n 级楼梯，它可以 1 次爬 1 级、2 级...n 级
    // - 求一共有多少种爬法？
    // - - n = 1；有一种爬法
    // - - n = 2；2种
    // - - n = 3；3（可以直接爬 3 级）；2-1、1-1-1（可以先递归爬 2 级，再爬 1 级），1-2（可以先递归爬 1 级，再爬 2 级）
    // - 递归表达
    // - - 爬 n 级楼梯，可以直跳 n 级
    // - - 爬 n 级楼梯，可以先递归爬上 n-1 级，再跳 1 级，f(n-1)
    // - - 爬 n 级楼梯，可以先递归爬上 n-2 级，再跳 2 级，f(n-2)
    // - - ...
    // - - 爬 n 级楼梯，可以先递归爬上 1 级，再跳 n-1 级
    // fn = f(n-1) + f(n-2) + f(n-3) + ... + f(1) + f(0); fn(0) = 1

    // 函数体描述
    // - 结束递归判断，仅有 0 级楼梯，直接返回 1
    // - 生成 [0, 1, 2, ..., n-1]，使用 reduce 累加和

    // 调用
    console.log(steps(10)) // 512
 * ```
 * 
 */
function steps(n) {
  // - 结束递归判断，仅有 0 级楼梯，直接返回 1
  if (n === 0) {
    return 1
  }
  // - 生成 [0, 1, 2, ..., n-1]，使用 reduce 累加和
  return [...Array(n)].map((_, i) => i).reduce((s, i) => {
    return steps(i) + s
  }, 0)
}

/**
 * 蚂蚁爬楼梯问题（自下而上构造 steps 函数）
 * @param {number} n - 楼梯级数
 * @example
 *
 * ```js
    // 重复子结构
    // - f(n) 需要求 f(0)...f(n-1) 各一次
    // - f(n-1) 需要求 f(0)...f(n-2) 各一次
    // - f(n-2) 需要求 f(0)...f(n-3) 各一次
    // - ...
    // - 太多重复子结构，思考从底层向上构造递归程序

    // 函数体描述
    // - 定义数组 s = [1, 1]，用以存储已计算的值
    // - 从 2 开始循环计算，reduce 每次累加和存入 s，每次循环取数组中的已缓存的值进行计算
    // - 返回 s 最后一个元素为结果

    // 调用
    console.log(steps_up(10)) // 512，s = [1, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
 * ```
 *  
 */
function steps_up (n) {
  // - 定义数组 s = [1, 1]，用以存储已计算的值
  const s = [1, 1]
  // - 从 2 开始循环计算，reduce 每次累加和存入 s，每次循环取数组中的已缓存的值进行计算
  for (let i = 2; i <= n; i++) {
    s[i] = s.reduce((a, b) => a + b)
  }
  // - 返回 s 最后一个元素为结果
  return s.pop()
}