/**
 * @example
 *
 * ```js
    // 堆（Heap）
    // - 建堆（create/build）- O(n)
    // - 堆化（heapify）-O(lgn)
    // - 插入（insert）-O(lgn)
    // - 取出（extract）-O(lgn)
    // - 修改权重（increase/decrease）-O(lgn)

    // 二叉树(数组表示)
    // - [15, 12, 8, 7, 5, 2, 3, 4, 1]; 15 > ( 12 > ( 7 > ( 4 + 1 ) + 5 ) + 8 > ( 2, 3 ) );
    // - 对序号为 k 的节点
    // - - 左子节点序号 2k + 1
    // - - 右子节点序号 2k + 2
    // - - 父节点序号 k/2 向下取整

    // 最大堆(Max-Heap)
    // - 父节点总是大于子节点
    // - 顶部是最大值
    
    // 最小堆(Min-Heap)
    // - 父节点总是小于子节点
    // - 顶部是最小值

    // 最大堆化（max-heapify）
    // - 和子节点不断比较，将最大值和自己交换
    // - 维护最大堆性质

    // 最大堆化（max-heapify）的性质
    // - 小于等于 3 个节点时，max-heapify 能构建最大堆
    // - 对左右子树都是最大堆的节点，max-heapify 能构建最大堆
    // - 归纳法：最底层条件 + 递推条件

    // 利用 max-heapify 建堆
    // - 给定一个乱序的二叉树，将它变成一个堆的过程
    // - { 12: { 15: { 4: {6: '', 5: ''}, 3: '' }, 2: {8: '', 7: ''} } }
    // - 第一次 max-heapify; 4: {6: '', 5: ''} ==> 6: {4: '', 5: ''}
    // - 第二次 max-heapify; 2: {8: '', 7: ''} ==> 8: {2: '', 7: ''}
    // - 第三次 max-heapify; 15: { 4: {6: '', 5: ''}, 3: '' } ==> 15: { 6: {4: '', 5: ''}, 3: '' }
    // - 第四次 max-heapify; { 12: { 15: { 4: {6: '', 5: ''}, 3: '' }, 2: {8: '', 7: ''} } } ==> { 15: { 12: { 6: {4: '', 5: ''}, 3: '' }, 8: {2: '', 7: ''} } }

    // 核心问题：倒数第一个分支节点的序号是？
    // - 观察规律，共有 ( n/2 向下取整 ) 个叶子节点
    // - 倒数第一个分支节点的序号 idx: idx = n - n/2 - 1 = n / 2 - 1
    // - 如何证明？
    // - - 对一个元素个数为 n 的堆，其中倒数第 2 层分支节点个数为 a，分支节点点数量为 k。最后 1 层为 x 个。
    // - - n = 2^0 + 2^1 + 2^2 + ... + 2^(h-1) + x; x = 2a, x 为偶数；x = 2a + 1，x 为奇数；
    // - - ==> n = 2^h-1+2a, x 为偶数；n = 2^h+2a-2, x 为奇数；
    // - - ==> k = 2^(h-1) - 1 + a; 2k = 2^h + 2a - 2;
    // - - ==> n = 2k + 1, x 为偶数；n = 2k，x 为奇数；
    // - - ==> k = (n/2 向下取整)
 * ```
 * 
 */